//予定:かつてのRPGのように操作し、複数の難易度から選ばせる
//二次元配列について(関数プロトタイプの引数の指定)の考慮が不足していた.
/*関数で使う変数などの吟味を全くせずに思いあたりで書いていたのが災いし
  後半では変数の取扱いについて散々苦労することになった
  大人しくグローバル変数を使うべきだった
*/

#include<stdio.h>
#include<stdlib.h>
#include<ctype.h>
#include<string.h>
#include<math.h>
#include<time.h>
#include<termios.h>

#define COL_DEF (printf("\x1b[39m"))
#define COL_IR (printf("\x1b[30m"))
#define COL_R (printf("\x1b[31m"))
#define COL_O (printf("\x1b[38;5;208m"))
#define COL_Y (printf("\x1b[33m"))
#define COL_G (printf("\x1b[32m"))
#define COL_B (printf("\x1b[36m"))
#define COL_I (printf("\x1b[38;5;56m"))
#define COL_V (printf("\x1b[95m"))
#define COL_UV (printf("\x1b[97m"))

#define MAP_X 40
#define MAP_Y 47
#define SIGHT_X 20
#define SIGHT_Y 10

#define SIZE 256
#define CORRECT 0
#define MID 0
#define CLOSE 1
#define FAR 2

#define DEBUG 1

enum color{IR=1,R,O,Y,G,B,I,V,UV};


typedef struct{
  unsigned int color:4;
  unsigned int unit:1;
  unsigned int defeat:1;
  unsigned int wall:1;
}tile_t;

typedef struct{
  unsigned int max;
  int min;
  unsigned int right;
}targ_t;

typedef struct{
  int close;
  int far;
  int dif;
}watch_t;

void set_map(tile_t tile[MAP_Y][MAP_X]);

tile_t* move_map(tile_t tile[MAP_Y][MAP_X],int rank);
void show_map(tile_t tile[MAP_Y][MAP_X],int pl_x,int pl_y,int rank);
int watch(watch_t*,int mode);
void sign(void);

int talk(int color,int defeat);

int high_low(targ_t*,int rank);
int set_target(targ_t*,int color);
int get_number(targ_t*,watch_t*);
int comp_number(targ_t*,int chose,int rank);
int info(watch_t*);

void opening(void);
void sub_opening(void);
void ending(void);
void clear(void);

char inputc(void);

int cheat=0;

int main(int argc,char* argv[])
{
  tile_t tile[MAP_Y][MAP_X];
  tile_t* tile_p;
  int rank=IR;
  int def;
  int col;
  int vct;
  targ_t targ;

  srand((unsigned)time(NULL));

  if(argc>=2){
    if(strcmp(argv[1],"cheat")==0){
      cheat=1;
    }
  }

  set_map(tile);
  
  opening();

  show_map(tile,20,44,rank);

  sub_opening();

  while(1){
    tile_p=move_map(tile,rank);

    targ.right=set_target(&targ,tile_p->color);

    vct=high_low(&targ,rank);


    if(vct==1 && tile_p->defeat==0){
      talk(tile_p->color,1);

      if(rank==UV){
	ending();
	exit(EXIT_SUCCESS);
      }

      rank++;
      tile_p->defeat=1;

    }
    
  }
  
  ending();
  
  return EXIT_SUCCESS;
}


void set_map(tile_t tile[MAP_Y][MAP_X]) //横幅MAP_X,縦幅MAP_Yのマップを生成(事前に作成したものを使う)
{
  int i,j;
  char c=0;
  FILE* fp=fopen("map_wall.dat","r");

  if(fp==NULL){
    fp=fopen("map_wall.dat","w");

    fprintf(fp,"1111111111111111111111111111111111111111\n1111111111111000000000000001111111111111\n1111111111111000000000000001111111111111\n1111111111111000000000000001111111111111\n1111111111111000000UV0000001111111111111\n1111111111111000000000000001111111111111\n1111111111111000000000000001111111111111\n1111111111111000000000000001111111111111\n1111111111111##############1111111111111\n1111111000000000000000000000000001111111\n1111111000000000000000000000000001111111\n100000#00000000000000000000000000#000001\n100000#00000000000000000000000000#000001\n100V00#00000000000000000000000000#00I001\n100000#00000000000000000000000000#000001\n100000#00000000000000000000000000#000001\n1111111000000000000000000000000001111111\n1111111000000000000000000000000001111111\n100000#000000000000000000000000001000001\n100000#000000000000000000000000001000001\n100B00#00000000000000000000000000100G001\n100000#000000000000000000000000001000001\n100000#000000000000000000000000001000001\n1111111000000000000000000000000001111111\n1111111000000000000000000000000001111111\n100000#00000000000000000000000000#000001\n100000#00000000000000000000000000#000001\n100Y00#00000000000000000000000000#00O001\n100000#00000000000000000000000000#000001\n100000#00000000000000000000000000#000001\n1111111000000000000000000000000001111111\n1111111000000000000000000000000001111111\n100000#00000000000000000000000000#000001\n100000#00000000000000000000000000#000001\n100R00#00000000000000000000000000#00i001\n100000#00000000000000000000000000#000001\n100000#00000000000000000000000000#000001\n1111111000000000000000000000000001111111\n1111111000000000000000000000000001111111\n1111111000000000000000000000000001111111\n1111111000000000000000000000000001111111\n11111110000000000000!0000000000001111111\n1111111000000000000000000000000001111111\n1111111000000000000000000000000001111111\n11111110000000000000@0000000000001111111\n1111111000000000000000000000000001111111\n1111111111111111111111111111111111111111");


    fclose(fp);
    fp=fopen("map_wall.dat","r");
  }
  
  for(i=0;i<MAP_Y;i++){
    for(j=0;j<MAP_X;j++){
      
      c=fgetc(fp);

      tile[i][j].color=0;
      tile[i][j].unit=0;
      tile[i][j].defeat=0;

      if(c=='0'){
	tile[i][j].wall=0;
      }else{
	tile[i][j].wall=1; //床を0とし、通り抜け不能の意味でそれ以外はwall=1
      }

	
      if(i==8 && j>=13 && j<=26){ //少々強引に移動制限床の色分け
	tile[i][j].color=UV;
      }
      if(j==6){
	if(i>=11 && i<=15){
	  tile[i][j].color=V;
	}else if(i>=18 && i<=22){
	  tile[i][j].color=B;
	}else if(i>=25 && i<=29){
	  tile[i][j].color=Y;
	}else if(i>=32 && i<=36){
	  tile[i][j].color=R;
	}

      }else if(j==33){
	if(i>=11 && i<=15){
	  tile[i][j].color=I;
	}else if(i>=18 && i<=22){
	  tile[i][j].color=G;
	}else if(i>=25 && i<=29){
	  tile[i][j].color=O;
	}else if(i>=32 && i<=36){
	  tile[i][j].color=IR;
	}

      }

      if(i==4 && (j==19 || j==20)){ //人物であることを表すunit=1,UVは横に2マス使っておく
	tile[i][j].color=UV;
	tile[i][j].unit=1;
      }
      if(j==3){
	if(i==13){
	  tile[i][j].color=V;
	  tile[i][j].unit=1;
	}else if(i==20){
	  tile[i][j].color=B;
	  tile[i][j].unit=1;
	}else if(i==27){
	  tile[i][j].color=Y;
	  tile[i][j].unit=1;
	}else if(i==34){
	  tile[i][j].color=R;
	  tile[i][j].unit=1;
	}

      }else if(j==36){
	if(i==13){
	  tile[i][j].color=I;
	  tile[i][j].unit=1;
	}else if(i==20){
	  tile[i][j].color=G;
	  tile[i][j].unit=1;
	}else if(i==27){
	  tile[i][j].color=O;
	  tile[i][j].unit=1;
	}else if(i==34){
	  tile[i][j].color=IR;
	  tile[i][j].unit=1;
	}

      }
      
      if(i==41 && j==20){ //看板の属性は色なしのユニット
	tile[i][j].color=0;
	tile[i][j].unit=1;
      }
      if(i==44 && j==20){ //主人公の初期地点を床にしておく
	tile[i][j].wall=0;
      }
	
	
    }
    fgetc(fp); //改行を読み流す
  }

  fclose(fp);

  remove("map_wall.dat");

}


void show_map(tile_t tile[MAP_Y][MAP_X],int pl_x,int pl_y,int rank)
{
  int i,j;

  for(i=0;i<MAP_Y;i++){
    for(j=0;j<MAP_X;j++){
      
       if(i<pl_y+SIGHT_Y && i>pl_y-SIGHT_Y){ //y(i)が視野内である  -2つ合わせて見える条件とする
      	if(j<pl_x+SIGHT_X && j>pl_x-SIGHT_X){ //x(j)が視野内である-
	  
	  if(tile[i][j].wall==0){//通り抜け可能(=床)
	    if(pl_x==j && pl_y==i){
	      switch(rank){
	      case IR:
		COL_IR; //define定数が置き換えであることを利用して、強引に関数的なものとして扱う
		break;
	      case R:
		COL_R;
		break;
	      case O:
		COL_O;
		break;
	      case Y:
		COL_Y;
		break;
	      case G:
		COL_G;
		break;
	      case B:
		COL_B;
		break;
	      case I:
		COL_I;
		break;
	      case V:
		COL_V;
		break;
	      case UV:
		COL_UV;
		break;
	      }

	      printf("@");
	      COL_DEF;
	    }else{
	      printf(".");
	    }
	  }else{
	    if(tile[i][j].unit==0){ //ユニットである
	      switch(tile[i][j].color){
	      case IR:
		COL_IR;
		break;
	      case R:
		COL_R;
		break;
	      case O:
		COL_O;
     		break;
	      case Y:
		COL_Y;
		break;
	      case G:
		COL_G;
		break;
	      case B:
		COL_B;
		break;
	      case I:
		COL_I;
		break;
	      case V:
		COL_V;
		break;
	      case UV:
		COL_UV;
		break;

	      }
	      printf("#"); //単なる壁
	      COL_DEF;

	    }else{
	      switch(tile[i][j].color){ //ユニットの色を調べる
	      case 0:
		printf("$"); //立て札的な何か
		break;
	      case IR:
		COL_IR;
		printf("@");
		COL_DEF;
		break;
	      case R:
		COL_R;
		printf("@");
		COL_DEF;
		break;
	      case O:
		COL_O;
		printf("@");
		COL_DEF;
		break;
	      case Y:
		COL_Y;
		printf("@");
		COL_DEF;
		break;
	      case G:
		COL_G;
		printf("@");
		COL_DEF;
		break;
	      case B:
		COL_B;
		printf("@");
		COL_DEF;
		break;
	      case I:
		COL_I;
		printf("@");
		COL_DEF;
		break;
	      case V:
		COL_V;
		printf("@");
		COL_DEF;
		break;
	      case UV:
		COL_UV;
		printf("@");
		COL_DEF;
		break;
	      }
	      
	      
	    }
	  }
	  
	}
       }
       if(j>pl_x+SIGHT_X){ //過去の(RPGを作った)自分によると、これで画面を主人公中心にできるらしい
	 break;
       }
    
    }
    if(i>pl_y+SIGHT_Y){ //同上
      break;
    }

    puts(""); //横ループ終了なので改行
  }
  
  
}

tile_t* move_map(tile_t tile[MAP_Y][MAP_X],int rank)
{
  static int pl_x=20,pl_y=44;
  static int p_x;
  static int p_y;
  static char message[SIZE]={};
  int i;
  int fight_col=0;

  while(fight_col==0){

    clear(); //前のマップがチラッと見えると気になるので流しておく

    show_map(tile,pl_x,pl_y,rank);

    puts(message); //メッセージを配列messageに蓄積し、ここで表示させる
    for(i=0;i<SIZE;i++){ //きれいにしておく
      message[i]=0;
    }

    p_x=pl_x;
    p_y=pl_y;

    switch(inputc()){ //斜め含む移動方向の指定
    case '1':
      p_x=pl_x-1;
      p_y=pl_y+1;
      break;
    case '2':
      p_y=pl_y+1;
      break;
    case '3':
      p_x=pl_x+1;
      p_y=pl_y+1;
      break;
    case '4':
      p_x=pl_x-1;
      break;
    case '6':
      p_x=pl_x+1;
      break;
    case '7':
      p_x=pl_x-1;
      p_y=pl_y-1;
      break;
    case '8':
      p_y=pl_y-1;
      break;
    case '9':
      p_x=pl_x+1;
      p_y=pl_y-1;
      break;
    }

    if(tile[p_y][p_x].wall==0){
      pl_x=p_x;
      pl_y=p_y;
    }else{ //通り抜け不能である
      if(tile[p_y][p_x].color==0 && tile[p_y][p_x].unit==1){
	sign(); //解説用の看板
      }

      if(tile[p_y][p_x].color!=0){ //色がある
	if(tile[p_y][p_x].unit==1){ //人
	  if(tile[p_y][p_x].color-rank<=-2){
	    sprintf(message,"シミュレートする必要もなく弱い.\n");
	  }else{
	    if(tile[p_y][p_x].defeat==0){
	      fight_col=talk(tile[p_y][p_x].color,0);
	    }else{
	      fight_col=tile[p_y][p_x].color;
	    }
	    clear();

	  }

	}else{
	  if(tile[p_y][p_x].color<=rank){ //移動制限床の判定
	    pl_x=p_x;
	    pl_y=p_y;
	  }else{
	    sprintf(message,"すり抜けることができない.階級が足りないようだ.\n");
	  }

	}
      }
      
    }
    
  }
  
  return &tile[p_y][p_x];
}

void sign(void)
{
  static int seen=0;
  int i;
  char buf[SIZE];
  char* str0[]={"やはり看板のようだ.",
		 "しかし案内らしいことは何も書いていない.",
		 "書いてあることといえば,",
		 "「クイズに答えて正解を見抜こう!」",
		 "くらいのものだった.",
		 "一瞬正解とはなんなのか全くわからなかったが,",
		 "少し考えたところで思い出した.",
		 "この世界では数当てが非常に重要であることを.",
		 "実力の精査にも使われるし,血の気の多い人が喧嘩に使うこともある.",
		 "そして,あなたはある程度の実力を持っていた気がする.",
		 "その力の一つだろうか,あなたは自分の答えと正答の遠さを知ることができる気がする.",
		 "※ スキル「目利き」を入手しました.",
		 "※ 数当ての入力画面でスキル画面を開くことで,近いか遠いかの境界を調整できます.",
		 "前方も見てみると,ここは直方体のような形の部屋であることがわかる.",
		 "前方にはいくつかの色分けされた壁が左右にあるようだ.",
		 "色に何かの見覚えがあると思えば,これは階級の色だった.",
		 "さまざまな疑問が頭をよぎるが,自分の階級のIRに合わせて,",
		 "手前の右の壁から調べてみることにした."
  };
  char* str1[]={"「クイズに答えて正解を見抜こう!」",
		 "これはクイズに正解できれば正解がわかるようになる,ということだろうか?",
		 "だとすれば異常に強い能力だが,胡散臭い.",
		 "やってみようか?(y/n):",
		 "ただでさえこんな謎の場所にいて,こんな胡散臭いものなどやっていられない.",
		 "あなたは再び探索を開始した.",
		 "能力はこれ以上なく有用だ.やってみる価値はあるだろう.",
		 "そう判断したあなたは,クイズに挑戦してみることにした.",
		 "しかし,どうやってクイズが始まるのだろう?と考えていると……",
		 "「第一問!」",
		 "看板から音声が流れ,勝手に始まった.どういう仕組みなのだろう?",
		 "「この世界には色の階級がありますが,この色はどういった法則があるでしょうか!」",
		 "問題は全て英小文字で回答しろ,というよくわからない注釈がある.",
		 "答えを入力してください:",
		 "どうやら正解できたらしい.",
		 "「第2問!」",
		 "「階級の法則は創造神があるゲームから考えだしましたが,そのゲームとはなんでしょうか!」",
		 "創造神の世界にもゲームがあるらしい.",
		 "しかしこんなもの,どう答えろというのだろうか.",
		 "答えを入力してください:",
		 "どうやら正解してしまったらしい.",
		 "「おめでとうございます!これにて能力を授けます!」",
		 "とんでもない力を手に入れた気がする."
  };

  if(seen==0){
    for(i=0;i<18;i++){
      puts(str0[i]);
      inputc();
    }
    seen=1;
    
  }else if(seen==1){
    for(i=0;i<4;i++){
      puts(str1[i]);
      inputc();
    }
    
    fgets(buf,SIZE,stdin);
    
    if(buf[0]=='y'){
      for(i=6;i<14;i++){
	puts(str1[i]);
	inputc();
      }
      
      fgets(buf,SIZE,stdin);
      
      if(strncmp(buf,"light\n",6)==0){
	puts("「正解!」");
	inputc();
	
	for(i=14;i<20;i++){
	  puts(str1[i]);
	  inputc();
	}
	
	fgets(buf,SIZE,stdin);
	
	if(strncmp(buf,"paranoia\n",9)==0){
	  puts("「正解!」");
	  inputc();
	  
	  for(i=20;i<23;i++){
	    puts(str1[i]);
	    inputc();
	  }
	  cheat=1;
	  seen=2;
	}else{ 
	  puts("「不正解!」");
	  inputc();
	  puts("音声は途切れてしまった.");
	  inputc();
	}
      
      }else{
	puts("「不正解!」");
	inputc();
	puts("音声は途切れてしまった.");
	inputc();
      }
    
    }else{
      for(i=4;i<6;i++){
	puts(str1[i]);
	inputc();
      }
    }


  }

}



int talk(int color,int defeat)
{
  int i;
  char* str_ir[]={"どうやらこの色付きの壁は自分の階級以下の色ならば通れるようになっているようだ.",
		  "そして,壁を通った先には一人の階級IRと思われる男がいた.",
		  "「よう,新入りか?」",
		  "壁の内側には一人ずつの人が配置されているのだろうか?",
		  "「何のことかわからないな.」",
		  "「気がつけばここにいたんだから状況なんてわかるはずもねえだろうな.」",
		  "「俺のことを知っているのか?」",
		  "「ああ,知ってるさ.」",
		  "この男は一体何者なんだろうか?",
		  "「一体ここはどこなんだ?」",
		  "「あいにくそれを教えることはできねえな.」",
		  "「なぜだ?」",
		  "「口止めされてるからな.」",
		  "不意に男の姿勢がこわばる.",
		  "「だが,それでも一つだけ言えることはあるぜ.」",
		  "「なんだ?」",
		  "「お前は俺と勝負しなきゃいけねえってことだ!」",
		  "突然男が戦闘態勢をとった.",
		  "こちらも無抵抗でやられたくはないので応戦する.",

		  "勝つことができたが,この男の意図がわからない.",
		  "「なぜ突然勝負を仕掛けてきたんだ?」",
		  "「そのうちわかるさ.」",
		  "その発言に戸惑っていたところ,あなたの体は薄く赤く輝き始めた.",
		  "「これはなんなんだ?」",
		  "不安から尋ねた.",
		  "「今,お前は昇格しようとしてんだ.」",
		  "「昇格?そんなことができるのか?」",
		  "昇格の権限はUVや一部のVに限るはずだ.",
		  "「ま,多少はな?」",
		  "より一層この男の存在に困惑する.",
		  "「生き残りてえなら,今そうしたように上の連中と戦って昇格を繰り返せ.」",
		  "「そうしたところで,君たちには何の得があるんだ?」",
		  "「得?んなもんねえよ,俺らにはな.」",
		  "「じゃあなぜ──」",
		  "「それ以上は答えらんねえ,さっさと行きな.」",
		  "半ば追い払われるようにしてその場を離れた.",
		  "気づいたときには,自分の階級は１つ上のRになっていた.",
		  "男の話によると,他の壁にも同じように人がいて,勝負で勝てば昇格できるようだ.",
		  "とりあえず,ここから見て前方にある赤い壁に向かってみよう."};
  
  char* str_r[]={"壁を抜けると,今度は小柄な女性が待っていた.",
		 "「こんにちは.」",
		 "普通に挨拶されてしまったので,挨拶を返す.",
		 "「ああ,こんにちは.」",
		 "「彼から話は聞いた?」",
		 "『彼』というのはIRの男のことだろう.",
		 "「ああ,意図はわからなかったけど,することは聞いたよ.」",
		 "「であればもう始めましょう.」",
		 "早くも女性は戦闘態勢をとった.",
		 "「待ってくれ,まだ頭が混乱しているんだ.」",
		 "「問答無用です,私には解決できませんので.」",
		 "どうやら話をさせてはくれなさそうなので,渋々応戦する.",
		 "階級が上がったからか,力が増した気がする.",
		 "※ 階級が上がったことで,数当てのときに複数の数を選べるようになりました.",
		 "※ Rの場合,選んだ数値を中心に±5となります.",
		 "※ この能力は階級が上がるほど強力になります.",
		 "※ なお,目利きの基準は選んだ数値となります.",

		 "「なるほど,やりますね.」",
		 "「頼む,教えてくれ,君たちは一体何者なんだ?」",
		 "「教えるわけにはいきません.ただ一つ,言えることは……」",
		 "「ここでの事は,恐らくあなたにとってプラスになります.」",
		 "「どういう意味だ?」",
		 "「そのうちわかりますよ.」",
		 "女性は優しげに微笑んだが,こちらはちんぷんかんぷんだ.",
		 "そうしてやりとりをしていると,今度はあなたの体が薄く橙色に輝いた.",
		 "どうやら彼女にも昇格の権限があるらしい.",
		 "「あとは全部彼が喋ってしまったでしょうし……」",
		 "「次のところに行ってください,ここから出て左前です.」",
		 "これ以上話してはくれなさそうなので,次の場所に向かうことにした.",
		 "気がつくと,あなたの階級はOになっていた.",
  };

  char* str_o[]={"壁を抜けると,明るそうな青年がいた.",
		 "「やあ,もう僕のところに来たのか.」",
		 "「いつになったら俺は情報を教えてもらえるんだ?」",
		 "「あなたのクリアランスにその情報は開示されていません……なんてね.」",
		 "なんとなく,彼の今の発言で寒気がした.",
		 "「少なくとも,残念ながら僕の身では答えることはできないよ.」",
		 "「僕にできるのは,君と戦って君の階級を上げることだけさ.いつでもおいで.」",
		 "そうは言われても,目的がわからなければなにもできない.",
		 "「俺の階級を上げてなんになるんだ?」",
		 "「そんなの知らないよ.そうしろって言われてるからね.」",
		 "「じゃあ俺はどうすれば…」",
		 "「もっと先に進めばわかると思うよ.」",
		 "男が真面目な顔になって答える.",
		 "「じゃあ,やるしかないか…」",
		 "あなたは戦闘態勢をとる.",
		 "「そうこなくっちゃね.」",
		 "男も合わせて戦闘態勢をとり,戦闘が始まった.",

		 "「ふう,君も強くなってきたんじゃないかな?」",
		 "確かに力が強くなっているのを感じる.",
		 "あなたの体が黄色に輝き始めた.",
		 "これらの光があなたに力を与えている気がする.",
		 "「疑問だらけで大変だと思うけど,頑張ってね.次は正面だよ.」",
		 "男は笑顔で送り出してくれる.",
		 "質問しても答えは返ってこないことがわかったので,",
		 "「ありがとう.」とだけ返し,次の場所へ向かった."
  };

  char* str_y[]={"壁を抜けると,フードを深くかぶった少年がいた.",
		 "「白磁の導きにて迷いし者よ,汝何を望む?」",
		 "小さい声でよくわからない言い回しをするので,理解に時間がかかる.",
		 "「一番もらいたいのは情報だけど,教えてもらえそうにないし戦って階級を上げたいかな.」",
		 "「それよりも,君の喋り方はわかりづらいから普通に喋ってくれないかな?」",
		 "「え,やだ……ゴホン,詠唱とは古よりのものなりて,我が言葉の姿は必然なり.」",
		 "「そうなんだ.ところで,君は──」",
		 "「くっ!!」",
		 "突然少年が右腕を抑える.",
		 "「ど,どうしたんだ!?」",
		 "「我が右腕に封印されし暗黒龍が暴走している…!」",
		 "「え?」",
		 "「だめだ,封印を突破されてしまう…仕方あるまい,我が制御,汝に預けるぞ…!」",
		 "突如少年がこちらを殺気立った目で睨みつけてくるので,戦闘態勢をとる.",
		 "「グアァッ!」",
		 "凶暴化した少年との戦闘が始まった.",

		 "「暗黒龍の封印の代償がこれほどとは…これも定めなのか,ルシフェルよ?」",
		 "「ともあれ,済まなかったな.」",
		 "封印した暗黒龍によって暴走してしまった,という話らしいが…どうだろう?",
		 "「詫びと言ってはなんだが…この呪われし龍の力の片鱗を授けよう.」",
		 "「ちょっと待ってくれ,君みたいになったりはしないよな?」",
		 "少し不安なので念のため尋ねる.",
		 "「案ずるな,我が浄化の済んだ部分を授ける.」",
		 "「だが心せよ,呪いの力に限らず,遍く力は人を堕落させる……」",
		 "「堕落すれば最後,汝闇に飲み込まれよう.」",
		 "「わかった,気をつけるよ.」",
		 "言い方はアレだが,内容は確かに大切な話だ.",
		 "あなたの体は薄く緑に輝き始めた.",
		 "「運命の針は汝の正面より少し左を指している……武運を.」",
		 "「ああ,どうも.」",
		 "ここを出て正面より少し左を目指すことにした."
  };

  char* str_g[]={"壁を抜けると,気の強そうな女性が待っていた.",
		 "「あんたね,呼び出された奴っていうのは.」",
		 "「ああ,そうだ.戦って,階級を上げにきた.」",
		 "「さっさと済ませましょ.ただ,あんたが欲しがってる情報だけど……」",
		 "「あたしに勝って,次のところでは色々わかるかもね.」",
		 "「それは本当か?」",
		 "「保証はない.それじゃ,もう始めましょう.」",
		 "素早く戦闘態勢をとったので,こちらも戦闘態勢をとる.",

		 "「強いわね……昇格させるわ.」",
		 "あなたの体が薄く青く輝く.",
		 "何かこの力は懐かしい感じがする.",
		 "ここにくる前の階級ははBだったのだろうか?",
		 "「次の場所は向かって正面よ.」",
		 "「わかった,どうも.」",
		 "はやる気持ちを抑えて,次の場所に向かうことにした."
  };

  char* str_b[]={"壁を抜けると,少し太った中年の男性がいた.",
		 "「ああ,君か……変わりないように見えるね.」",
		 "「変わりない?」",
		 "先ほどから昇格を繰り返しているのに,どういうことだろう?",
		 "「ああ,変わりない.ここにくる前の君と.」",
		 "「!!」",
		 "『ここにくる前』というワードにあなたは強く反応してしまう.",
		 "「あなたは誰なんだ?」",
		 "「単なる元同僚さ.」",
		 "「俺よりもずっと若いのに同じ階級と知ったときは驚いたなぁ……」",
		 "どうやらここにくる前の同階級の知り合いだったらしい.",
		 "やはりここにくる前のあなたの階級はBだったようだ.",
		 "「やはり…………かね……」",
		 "男性が聞き取れない声で独り言を言った.",
		 "「今,なんて?」",
		 "「あぁ,なんでもないよ.」",
		 "「さて,君がすべきことというのは知っている.勝負しようか.」",
		 "「ああ,勝負を.」",
		 "考えを振り払い,戦いに集中する.",

		 "「ははっ,やっぱり君は天才だよ」",
		 "「それはどうも……」",
		 "「しかも,前よりも強くなっている気がするよ」",
		 "あなたの体は藍色に輝き始めた.",
		 "「そうだ,なぜあなたはここにいる?」",
		 "「記憶はあるようだし,何か知っているんじゃ?」",
		 "「ああ,知ってるさ.だけども,教えるわけにはいかない.」",
		 "「どうしてみんな黙秘を?」",
		 "「命令だからさ.」",
		 "一体誰がこの人たちに命令を下しているんだろう?",
		 "「もっと知りたいなら,もっと上を目指す他はないよ.」",
		 "「なに,天才の君ならできるさ.」",
		 "「次の場所は,ここを出て左前にある.」",
		 "この流れを何度も繰り返してきたあなたはうんざりする.",
		 "「いつになったらこれは終わる?」",
		 "「もう終わりは近いよ.」",
		 "「まさか,UVに昇格するまで?」",
		 "「それは……その時までのお楽しみということにしておいてくれ.」",
		 "この状況でお楽しみなどと言ってはいられない気がするが…",
		 "とりあえず,左前を目指すことにした."
  };

  char* str_i[]={"壁を抜けると,白銀の髪をした男性が待っていた.",
		 "なにやら黒茶色の波打った刃の剣のようなものを持っている.",
		 "「もうついたのか!」「はやい!」「これで勝つる!」",
		 "どこからかそんな声が聞こえてきた.歓迎……なのか?",
		 "「Iから昇格したいので,勝負をさせてくれ.」",
		 "「俺がどうやってIだって証拠だよ.」",
		 "この人は外国人だろうか?文法が不自然だ.",
		 "「法則的にこの藍色の壁の中にはIの階級の人がいる.」",
		 "「だから,あなたはIに違いないんだ.」",
		 "なんとなくドヤ顔で言い切った.",
		 "「今までの法則通りに俺がIとでも思った浅はかさは愚かしい.」",
		 "「違うのか?」",
		 "「リアルで痛い目を見たいのかおれはリアルでIだから相当の力持ち……」",
		 "「やっぱりIじゃないか!」",
		 "「これ言わせたの絶対忍者だろ……汚いなさすが忍者きたない.あもりにもひきょう過ぎるでしょう?」",
		 "「おれをはめたことでおれの怒りが有頂天になった!この怒りはしばらくおさまる事を知らない!」",
		 "自分で情報を漏らして怒られても困るのだが……",
		 "しかしこれで勝負してもらえるなら好都合だろう.",
		 "「それじゃあ勝負で白黒付けよう.」",
		 "「時既に時間切れ,お前ハイスラでボコるわ……」",
		 "互いに戦闘態勢をとり,戦闘が始まった.",

		 "「いや今のハメでしょ?俺のシマじゃ今のノーカンだから.」",
		 "「負けは負けだ,大人しく認めてくれ.」",
		 "「昇格はさせてやる,見事な仕事だと関心はするがどこもおかしくはない.」",
		 "あなたの体は紫色に輝き始めた.",
		 "「次の目的地が正面の紫の壁なのは確定的に明らか.」",
		 "「今すぐ行くべきそうするべき.」",
		 "「ああ,どうも.」",
		 "非常に特殊な喋り方をする人だったが,一応することはしてくれたようだ.",
		 "彼に言われた通り,正面を目指すことにした.",
  };
  
  char* str_v[]={"壁を抜けると,漆黒の肌をした男が待っていた.",
		 "どんな日焼けをしてもこんな色にはならないだろうが,何があったのだろう?",
		 "「来たか.」",
		 "「ああ.その肌の色は一体どうしたんだ?」",
		 "「初対面の人間に対しての質問がこれとは,君にはデリカシーがないのかね?」",
		 "男はニヤニヤしながらそう言ってきた.",
		 "「ああ,全く困ったものだ.以前にも『お前は肌が真っ黒だからIRだ』なんて扱いを受けていたしな.」",
		 "ニヤニヤしたままの表情で悲惨な話を語った.",
		 "「えーと……すまなかった.」",
		 "何やら嫌味なやつだ.",
		 "「まあいい,戦いに来たんだろう?」",
		 "「ああ,そうだが,その前に何か俺に関して話をしてくれないか?」",
		 "「話?あいにく俺はお前のことを大して知らないし知る興味もない.」",
		 "「ああ,そうかい.」",
		 "いちいち癪に障る言い方をする男だ.",
		 "「さて,この世界ではこれだった……かな.」",
		 "ポケットをまさぐりながらよくわからない独り言を言う.",
		 "『この世界』とはなんだろうか?と思ったが,",
		 "Yの少年と同じような物だろうと思い,無視した.",
		 "「さて,じゃあ始めようか.」",
		 "「ああ.」",
		 "面倒なので短く返し,互いに戦闘態勢に入る.",
		 "「そうだ,せっかくだしハンデをつけないか?」",
		 "男がニヤニヤしながら尋ねてくる.",
		 "「いや,いい.」",
		 "しかしこの男はろくなことを喋らない気がするので断る.",
		 "「つまらんな……じゃあ,始めるか.」",
		 "構えなおし,戦闘を始めた.",

		 "「やるじゃないか.さすがは『天才』だな.」",
		 "『天才』を妙に強調して皮肉っぽく言った.",
		 "この男とはもう早く離れてしまいたい.",
		 "「そりゃどうも,早く昇格させてくれないか?」",
		 "「まあまあそう焦るな,少年よ.」",
		 "「せっかくだし歴史の勉強でもしていかないか?」",
		 "男の表情が突如歪んだ気がした.",
		 "「結構だ.早く昇格させてくれ.」",
		 "「全く,仕方がないな……」",
		 "あなたの体が白く輝き始める.",
		 "「俺が,ついにUVに……?」",
		 "「ああそうだ,おめでとう.」",
		 "男が心底どうでもよさそうに祝った.",
		 "「じゃあ俺は報酬もらって帰るから.」",
		 "「直方体を見かけたら俺を思い出してくれ.」",
		 "そんなわけのわからない言葉を最後に,彼はまばたきのうちに姿を消した.",
		 "他の人たちも壁を抜けてからこんな風に帰ったのだろうか?",
		 "しかも彼だけは次の場所を教えてはくれなかった.",
		 "とはいえ,残る部屋はここを出て左以外にないので言われなくともわかる.",
		 "次はそこへ向かうことにした."
  };

  char* str_uv[]={"壁を抜けると,二人の姉妹と思しきとても若い女性を見た.",
		  "その瞬間,あなたはひどい頭痛に襲われる.",
		  "「久しぶりね.」",
		  "あなたは姉の方をつい最近見たことがある.",
		  "急激に記憶を取り戻したことで起きた頭痛は収まってきた.",
		  "「気分はどうかしら?」",
		  "「……最悪だ.」",
		  "そう,この女性こそがあなたを連れ去った張本人なのだ.",
		  "「それはお気の毒に.」",
		  "「ところで,私たちのことは思い出した?」",
		  "「ああ,思い出したよ……」",
		  "この二人は,あろうことか物心ついたころに別れたあなたの姉と妹だった.",
		  "「最年少のUVと急激に進出したUVの話は噂に聞いていたけど,まさかね……」",
		  "「まさかあなた自身の姉妹だとは思わないでしょうね.」",
		  "「ああ.なんでこんなことをしたんだ?」",
		  "「お兄ちゃんが不憫からだよ.」",
		  "今まで一言も喋らなかった妹が答えた.",
		  "「不憫?」",
		  "「私たちはUVになったけど,お兄ちゃんはBのままだった.」",
		  "「そのままだと,私たちは一緒にいることが難しい.」",
		  "「お姉ちゃんの要望と,私もお兄ちゃんを見たかったからこうした.」",
		  "姉が頷く.",
		  "「でもこんなやり方しなくたっていいじゃないか?」",
		  "「UVの権限は強いけど,それでも制限があるの.」",
		  "「一人が立て続けに昇格させることはできないの.」",
		  "「だから,昇格の権限を各階級の人たちに分配して,一気にUVまで上がれるようにした.」",
		  "「もちろん相応の報酬を用意する必要があったし,」",
		  "「昇格の権限は向こう10年くらいは失われそうだし,」",
		  "「誘拐事件をもみ消す必要もあった.」",
		  "「そこまでのリスクを背負ってもやるべきことなのか…?」",
		  "「まあ,ただ単に普通に仕事ばかりをするのに飽きたっていうのもあるかな.」",
		  "「それだけのためにするのもおかしい気がするけど……」",
		  "「そうだ,なぜ誘拐事件なんて形にする必要が?」",
		  "「あなたはね,私たちに比べて妙に力が弱かったの.」",
		  "「同じ血を持っているのにUVとBの差が出るなんて不自然でしょう?」",
		  "「個人差とかではないのか?」",
		  "「それも考えたけど,昔,力の解析をしたときに十分強い力を感じたから.」",
		  "「だから抑制がかかってるんじゃないかと思って,」",
		  "「記憶をなくせば抑制が消えるんじゃないかと思って記憶を消したの.」",
		  "「実際,記憶を失う前に比べて新しい能力を手に入れたようだしね.」",
		  "だからといって記憶抹消なんて手段を取るのはどうなんだろうか.",
		  "「さて,その新しい力…私たちにも見せてちょうだい.」",
		  "「勝負すればいいのか?」",
		  "「ええ.」",
		  "「妹も参加するのか?」",
		  "「参加するよ.」",
		  "「さすがに上級のUV二人がかりは勝ち目がないぞ?」",
		  "「大丈夫,手加減はちゃんとするから.」",
		  "両方とも準備が整い,戦闘を始めた.",

		  "「格段に強くなったわね.」",
		  "「おかげさまで.」",
		  "少しだけ皮肉っぽく言う.",
		  "「まあ計画が荒唐無稽だったのは謝るわ.」",
		  "「でも結果的に強くなれたし,いいんじゃないかしら.」",
		  "色々納得がいかないが,これ以上言うのも無意味なので諦めた.",
		  "「じゃあ帰りましょうか.」",
		  "「帰ったときの俺の処遇はどうなってるんだ?」",
		  "「複数人のUVから推薦を受け,UVまでに昇格した,という形にしてあるわ.」",
		  "「至れり尽くせり……でいいのか?」",
		  "「いいと思うわよ.」"
  };

  clear();

  switch(color){
  case IR:
    if(defeat==0){ //遭遇したときの会話
      for(i=0;i<18;i++){
	puts(str_ir[i]);
	inputc();
      }

      clear();

    }else{ //こちらの勝利時の会話

      for(i=19;i<39;i++){
	puts(str_ir[i]);
	inputc();
      }

    }
    return IR;
    break;

  case R:
    if(defeat==0){
      for(i=0;i<17;i++){
	puts(str_r[i]);
	inputc();
      }
      clear();

    }else{

      for(i=17;i<26;i++){
	puts(str_r[i]);
	inputc();
      }

    }
    return R;
    break;

  case O:
    if(defeat==0){
      for(i=0;i<17;i++){
	puts(str_o[i]);
	inputc();
      }

      clear();
      
    }else{
      for(i=17;i<25;i++){
	puts(str_o[i]);
	inputc();
      }

    }
    return O;
    break;

  case Y:
    if(defeat==0){
      for(i=0;i<16;i++){
	puts(str_y[i]);
	inputc();
      }

      clear();

    }else{
      for(i=16;i<31;i++){
	puts(str_y[i]);
	inputc();
      }

    }
    return Y;
    break;

  case G:
    if(defeat==0){
      for(i=0;i<8;i++){
	puts(str_g[i]);
	inputc();
      }
      clear();

    }else{
      for(i=8;i<15;i++){
	puts(str_g[i]);
	inputc();
      }

    }
    return G;
    break;

  case B:
    if(defeat==0){
      for(i=0;i<19;i++){
	puts(str_b[i]);
	inputc();
      }
      clear();
      
    }else{

      for(i=19;i<39;i++){
	puts(str_b[i]);
	inputc();
      }
      
    }
    return B;
    break;

  case I:
    if(defeat==0){
      for(i=0;i<21;i++){
	puts(str_i[i]);
	inputc();
      }

      clear();

    }else{
      for(i=21;i<30;i++){
	puts(str_i[i]);
	inputc();
      }

    }
    return I;
    break;

  case V:
    if(defeat==0){
      for(i=0;i<28;i++){
	puts(str_v[i]);
	inputc();
      }
      clear();
    }else{
      for(i=28;i<48;i++){
	puts(str_v[i]);
	inputc();
      }
    }
    return V;
    break;

  case UV:
    if(defeat==0){
      for(i=0;i<49;i++){
	puts(str_uv[i]);
	inputc();
      }

      clear();

    }else{
      for(i=49;i<60;i++){
	puts(str_uv[i]);
	inputc();
      }

    }
    return UV;
    break;

  }

  clear();

  return color;

}


int high_low(targ_t* targ,int rank)
{
  int chs; //狙いを定める数値
  int ms=0;
  static watch_t watch={10,30,0};
  
  while(ms<5){
    chs=get_number(targ,&watch);
    
    watch.dif=comp_number(targ,chs,rank);

    info(&watch);

    if(watch.dif!=CORRECT){
      ms++;
    }else{
      break;
    }

  }
  if(ms<5){
    return 1;
  }else{
    puts("敗北した……");
    inputc();
    return 0;
  }

}


int set_target(targ_t* targ,int col) //答えの数値を生成
{
  int n;

  switch(col){
  case IR:
    targ->min=0;
    targ->max=100;
    break;
  case R:
    targ->min=0;
    targ->max=1000;
    break;
  case O:
    targ->min=0;
    targ->max=10000;
    break;
  case Y:
    targ->min=0;
    targ->max=100000;
    break;
  case G:
    targ->min=0;
    targ->max=1000000;
    break;
  case B:
    targ->min=0;
    targ->max=10000000;
    break;
  case I:
    targ->min=0;
    targ->max=100000000;
    break;
  case V:
    targ->min=0;
    targ->max=1000000000;
    break;
  case UV:
    targ->min=0;
    targ->max=2000000000;
    break;
  } 

  n=rand()%(targ->max - targ->min) + targ->min;

  if(cheat==1){
    printf("正答:%'d\n",n);
  }

  return n;
}


void skill(watch_t* wat)
{
  int chs;
  char buf[SIZE];

  clear();

  puts("1.目利きを調整する");
  puts("0.画面を閉じる");

  do{
    fgets(buf,SIZE,stdin);

  }while(buf[0]=='\n');

  sscanf(buf,"%d",&chs);
  
  switch(chs){
  case 1:
    watch(wat,1);
    break;
  default:
    break;
  }

  clear();


}


int watch(watch_t* wat,int mode)
{
  char buf[SIZE];
  int dif_cp=wat->dif;

  if(mode==0){
    if(wat->dif<0){
      dif_cp=-dif_cp;
    }

    if(dif_cp<wat->close){
      return CLOSE;
    }else if(dif_cp<wat->far){
      return MID;
    }else return FAR;

    
  }else if(mode==1){
    printf("現在の「かなり」の境界:%d\n",wat->far);
    printf("現在の「少しだけ」の境界:%d\n",wat->close);
    
    printf("「かなり」の境界を入力:");

    do{
      fgets(buf,SIZE,stdin);
    }while(buf[0]=='\n');

    sscanf(buf,"%d",&(wat->far));
    
    printf("「少しだけ」の境界を入力:");

    do{
      fgets(buf,SIZE,stdin);
    }while(buf[0]=='\n');

    sscanf(buf,"%d",&(wat->close));
    
  }
 
  return 0;
}



int get_number(targ_t* targ,watch_t* watch) //fgets(),sscanf()で数値を取得
{
  char buf[SIZE]={0};
  int n;
  
  printf("\n数値を入力してください.(%'d-%'d)(sと入力するとスキル画面へ):",targ->min,targ->max-1);
  do{
    
    for(n=0;n<SIZE;n++){
      buf[n]=0;
    }
    
    do{
      fgets(buf,SIZE,stdin);
      if(buf[0]=='\n'){
	printf("数値は正しく入力してください.:");
      }else if(buf[0]=='s'){
	skill(watch);
	buf[0]='\n'; //もう一度入力させる
	printf("\n数値を入力してください.(%'d-%'d)(sと入力するとスキル画面へ):",targ->min,targ->max-1); //そのままループさせるとわかりづらいので入力文を出す
      }

    }while(buf[0]=='\n');//改行のみはsscanfで5として認識してしまうようなので対策
                         //ついでに's'の判定もしておく

    if(isdigit(buf[0])){
      sscanf(buf,"%d",&n);
      
      if(n<targ->min || n>=targ->max){
	printf("数値は正しく入力してください.:");
      }
      
      
    }else{
      printf("数値は正しく入力してください.:");
    }
    
  }while(n<targ->min || n>=targ->max);
  
  return n;
}


int comp_number(targ_t* targ,int chose,int rank) //正答と入力を比べる
{
  int area=pow(10,rank-1)/2; //階級による伸び分の半分

  if(rank==IR){
    printf("あなたは%dを選んだ.\n",chose);
    if(chose==targ->right){
      return CORRECT;
    }
  }else{
    if(chose-area<0){
      printf("あなたは%'d-%'dを選んだ.\n",chose-area+targ->max,(chose+area)%targ->max);
    }else{
      printf("あなたは%'d-%'dを選んだ.\n",chose-area%targ->max,(chose+area)%targ->max);
    }
    
    if(chose+area>=targ->right && chose-area<=targ->right){//普通に範囲内か判定
      return CORRECT;
    }
    
    if(chose+area>=targ->max){//上限を越えた場合の処理
      if(chose+area%targ->max>=targ->right){
	return CORRECT;
      }
    }
    
    if(chose-area>0){//負の値になった場合の処理
      if(chose-area+targ->max<=targ->right){
	return CORRECT;
      }
    }
    
  }

  return targ->right-chose;
    
}

int info(watch_t* wat) //正答と入力の関係を表示
{
  if(wat->dif==CORRECT){
    puts("正しい数値を言い当てることができたようだ.");
  }else{
    printf("どうやら答えより");
    if(watch(wat,0)==CLOSE){
      printf("少しだけ");
    }else if(watch(wat,0)==FAR){
      printf("かなり");
    }else printf("いくらか");
    if(wat->dif>0){
      printf("低い");
    }else{
      printf("高い");
    }
    puts("数値を選んだようだ.");
    
  }

  inputc();

  return wat->dif;
}

void opening(void)
{
  int rank=B;
  int area=pow(10,rank-1)/2;
  int chs;
  int i;
  int j;
  char buf[SIZE];

  char* str[]={"ここは数当てでの能力が物を言う資本主義っぽい世界.",
	       "そんな世界で、あなたは比較的高いBの階級であり、",
	       "そこそこ平和に暮らしていた.",
	       "さて、今日も低階級のやつらを教育しながら仕事するかな……",
	       "などと今日の予定を考えていると……",
	       "ﾊﾞｰﾝ!!!",
	       "部屋の壁がすさまじい音を立てて崩れ落ちた.",
	       "「大人しくなさい,さもなくば命はないわ」",
	       "身なりを見るに、階級はUVの女性のようだ.",
	       "だが,顔などは隠してあり,詳細はわからない.",
	       "いつか恨みでも買ったのだろうか,なぜこんな急に訪問してきたのだろう?",
	       "「豪快な入り方をなさって,最高階級様が一体なんの用だって言うんですか?」",
	       "「あら,従ってくれないのかしら?」",
	       "「御上様とはいえ壁をぶち破って入る人には従いたくはありません,と言いたいところですが──」",
	       "何者なのかわからないが,最高階級らしい威厳があり,力で勝てる相手ではないと思わされる.",
	       "「UV様に逆らうのは自殺行為ですからね,大人しく投降しますよ」",
	       "「賢明な判断で助かるわ.それでは今からあなたを誘拐します」",
	       "「さすがにその要求は大人しく飲めませんよ」",
	       "誘拐となれば話は別だ.威圧感から足が震えるが,なんとか抑えて戦闘態勢に移る.",
	       "「強情ですね……ならば力づくで連れ去らせてもらいましょう」",
	       "「所詮この程度ですか,Bの実力などたかが知れていましたね」",
	       "敗北し、倒れたあなたの前で女性は言い放った.",
	       "「白磁の声に応えよ.彼の者から全てを奪取せよ.」",
	       "意識を失っていくあなたはそんな声を聞いた気がした.",
	       "………",
	       "……",
	       "…",
  };

  for(j=0;j<3;j++){
    puts(str[j]);
    inputc();
  }
  
  clear();

  while(j<20){
    puts(str[j]);
    inputc();
    j++;
  }

  puts("");
  puts("");

  /*
    いわゆる負けイベントとしてそれらしいものを登場させる.
    仕様上,既存の関数が使い辛いので独自に書く.
   */

  //正答は存在しない.

  for(i=1;i<=5;i++){
    printf("数値を入力してください(%'d-%'d)",0,999999999);

    do{
      do{
	fgets(buf,SIZE,stdin);
	if(buf[0]=='\n'){
	  printf("数値は正しく入力してください.:");
	}
      }while(buf[0]=='\n');
      
      sscanf(buf,"%d",&chs);
      if(chs<0 || chs>=100000000){
	printf("数値は正しく入力してください.");
      }
    }while(chs<0 || chs>=100000000);
    
    if(chs-area<0){
      printf("あなたは%'d-%'dを選んだ.\n",chs-area+100000000,(chs+area-1)%100000000);
    }else{
      printf("あなたは%'d-%'dを選んだ.\n",chs-area%100000000,(chs+area-1)%100000000);
    }
    
    puts("数値を当てることができなかったようだ.");
  }
  clear();

  while(j<25){
    puts(str[j]);
    inputc();
    j++;
  }

  clear();

  sleep(1);



}


void sub_opening(void)
{
  int i;
  char* str[]={"気がつくとあなたは見知らぬ建物の中に横たわっていた.",
	       "何やら小奇麗になっていて,あるいは何かのアジトのようでもある.",
	       "また,これまでの記憶が全くない.",
	       "なぜここにいるのか,さらには自分が何者だったのかも思い出せない.",
	       "少なくとも自分の格好を見るに,自分の階級は最低辺のIRのようだ.",
	       "目の前に立て札のようなものがある.",
	       "位置からして案内か何かだろう,読めば記憶が整理できるかもしれない.",
	       "あなたは起き上がり,探索を開始した."
  };

  for(i=0;i<8;i++){
    puts(str[i]);
    inputc();
  }

}


void ending(void)
{
  char* str[]={"そんなやりとりをして,あなたたちは新しい家へ帰る.",
	       "これからのUVとしての新生活は充実し,姉妹とも仲良くやることだろう.",
	       "-完-"
  };
  int i;

  for(i=0;i<3;i++){
    puts(str[i]);
    inputc();
  }

}


void clear(void)
{
  int i;

  for(i=0;i<30;puts(""),i++); //30行の空行で端末の情報を上に流す(単なる整形)

}


char inputc(void) //非カノニカルモードで1文字を入力させる.文章確認などに使用.
{
  struct termios new_term,def_term;
  char c;

  tcgetattr(fileno(stdin),&def_term);

  new_term=def_term;

  new_term.c_lflag&=~ECHO;
  new_term.c_lflag&=~ICANON;

  tcsetattr(fileno(stdin),TCSANOW,&new_term);

  c=getchar();

  tcsetattr(fileno(stdin),TCSANOW,&def_term);

  return c;
}
